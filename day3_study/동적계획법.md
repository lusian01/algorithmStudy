동적계획법 - Dynamic Programming, DP  / 큰 문제를 작은 문제로 나눠서 푸는 알고리즘.

1. 큰 문제를 작은 문제로 나눠서 푸는 기법
 - 분할정복과 비슷하나, 메모이제이션을 필요로 하지 않음. 계산한 부분 문제를 한번만 쓰고 더 이상 사용하지 않음

2. 이항계수 (nCr) 
 - bino(a,b) = bino(a-1, b) + bino(a-1, b-1)

3. 메모이제이션 ( Memoization )
 -  결과를 저장한 뒤, 중복을 제거하는 기법

4. Top - Down
 - 재귀와 같은 방식
 - Fibonachi : fib(n) = fib(n-1) + fib(n-2)

4. Bottom - Up
 - For문 이용
 - for ( i = 2 , i < n, i ++) fib(i) = fib(i-1) + fib(i-2)

5. 최적값을 구할때 사용된다. 

6. DP Guide line
 -  몇 차원 (변수의 수) DP를 할 것인가?
 - 변수 개수(=차원)가 정해졌으면 각각의 변수가 무슨 의미인가?
 - DP값이 어떤 의미인가?
 - 어떤 DP값과 다른 DP값의 관계가 있는가? 있으면 어떤 관계인가?
	--> DP 테이블 작성
 - 위의 점화식을 이용하여 재귀 또는 for문 DP로 계산한다.


7. 동적 계획법의 초기화

 - 계산된 값, 초기값의 구분으로 방문여부를 확인한다.
 - 0을 값으로 갖는다면 -1 (INFINITY or INT_MAX) 의 값을 주는게 보통이다

8. TOP - DOWN VS BOTTOM - UP

TOP - DOWN 방식 에 메모이제이션을 했다는 가정하에 시간복잡도는 같다. 
하지만 실제 걸리는 시간은 TOP - DOWN DP가 더 길다고 일반적으로 알려져 있다. 
재귀 DP의 장점은 점화식 그대로 호출이 되기 때문에 형식/순서에 얽매이지 않는다.
for문 DP의 장점은 시간이 (조금은) 적게 걸린다는 것이다. 그렇기 때문에 문제에 따라서 둘 중 어떻게 할지 잘 정해야 한다.




